#! /bin/bash


declare USER="$(whoami)"  # set it to the effective user ID name
declare CHTOOR_MARKER=".chtoor"  # the file name to visually denote the new root environment establishment
# For quick recognizing that the new root environment setup has been performed (i.e. some bind
# mounts to '${CHTOOR_DIR}/new_root' are created) the CHTOOR_MARKER file is placed into CHTOOR_DIR.
# If after setup complete, the '${CHTOOR_DIR}/new_root' directory appears to be write enabled, and
# it does not appear to be bind-mounted to the current root directory, the CHTOOR_MARKER file is
# additionally created therein for the new root directory hierarchy can be distiguished in some visual
# way after switching into it.

declare OPT_MODE="go"
declare OPT_CONFIG_FILE=""
while getopts "f:gsu" OPT; do
  case "$OPT" in
    f)  OPT_CONFIG_FILE="$OPTARG"
        if [ ! -f "$OPT_CONFIG_FILE" ]; then
          echo >&2 "*** config file: '$OPT_CONFIG_FILE' -- no such file; exit"
          exit 1
        fi
        ;;
    g)  OPT_MODE="go"
        ;;
    s)  OPT_MODE="setup"
        ;;
    u)  OPT_MODE="undo"
        ;;
   \?)  exit 1
        ;;
  esac
done
shift $((OPTIND-1))

declare CHTOOR_DIR="$1"  # the directory where to create the 'new_root'
[ -z "$CHTOOR_DIR" ] && { echo >&2 "*** CHTOOR_DIR: directory not specified; exit"; exit 2; }
[ -d "$CHTOOR_DIR" ] || { echo >&2 "*** CHTOOR_DIR: '$CHTOOR_DIR' -- not exist / not a directory; exit"; exit 2; }

declare NEW_ROOT="$CHTOOR_DIR/new_root"

declare RUN="/bin/bash -l"  # the command to run with the changed root directory
declare EXPORT=(DISPLAY)  # shell variables for export into new root environment
declare -A SETUP=(  # some minimal defaults to setup the 'new_root' directory hierarchy
    [/]=rbind-ro
    [/home/"$USER"]=own-create
    [/home/"$USER"/.bash_profile]=own-copy-missing
    [/home/"$USER"/.bashrc]=own-copy-missing
    [/home/"$USER"/.inputrc]=own-copy-missing
)


__verify-setup-methods() #20
{
  local method='' item_methods=''
  for item_methods in "${SETUP[@]}"; do
    method="${item_methods%%!*}"
    [ -z "$method" ] && continue  # skip empty records
    declare -F "$method" >/dev/null && continue
    echo >&2 "*** SETUP: '$method' -- unknown setup method; exit"
    exit 21
  done
  return 0
}
__verify-undo-methods() #20
{
  local method='' item_methods=''
  for item_methods in "${SETUP[@]}"; do
    method="${item_methods##*!}"
    [ -z "$method" ] && continue  # skip empty records
    [ "$method" = "$item_methods" ] && continue  # no undo method is specified; no matter if the default corresponding undo method exists
    declare -F "$method" >/dev/null && continue
    echo >&2 "*** SETUP: '$method' -- unknown undo method; exit"
    exit 21
  done
  return 0
}

case "$OPT_MODE" in
  (go | setup | undo)
      ## read the config file
      [ -z "$OPT_CONFIG_FILE" ] && OPT_CONFIG_FILE="$CHTOOR_DIR/chtoor.conf"
      if [ -f "$OPT_CONFIG_FILE" ]; then
        source "$OPT_CONFIG_FILE" || { echo >&2 "*** config file: '$OPT_CONFIG_FILE' -- source failure; exit"; exit 4; }
      fi
      ;;&
  (go | setup)
      if [ ! -f "$OPT_CONFIG_FILE" ]; then
        echo >&2 "*** config file: '$OPT_CONFIG_FILE' -- not found; fall back to minimal setup defaults"
      fi
      ;;&
  (go)
      RUN="${2:-$RUN}"
      [ -f "$CHTOOR_DIR/$CHTOOR_MARKER" ] || __verify-setup-methods
      ;;
  (setup)
      __verify-setup-methods
      ;;
  (undo)
      if [ ! -f "$OPT_CONFIG_FILE" ]; then
        echo >&2 "*** config file: '$OPT_CONFIG_FILE' -- not found; minimal default setup assumed"
      fi
      __verify-undo-methods
      ;;
esac


__is-same() #10
{
  local LHS="$(realpath -q -e "$1")" RHS="$(realpath -q -e "$2")"
  [ -n "$LHS" -a -n "$RHS" ]  &&
  {
    test "$LHS" = "$RHS"  ||
    {
      LHS="$(stat --printf="%d:%i" "$LHS")"
      RHS="$(stat --printf="%d:%i" "$RHS")"
      test "$LHS" = "$RHS"
    }
  }
}

__file-type()
{
  local t=""
  while true; do
    test -d "$1" && { t="directory"; break; }
    test -f "$1" && { t="regular file"; break; }
    test -b "$1" && { t="block special"; break; }
    test -c "$1" && { t="character special"; break; }
    test -p "$1" && { t="named pipe"; break; }
    test -S "$1" && { t="socket"; break; }
    break;
  done
  test -L "$1" && t="symbolic link / $t"
  echo "$t"
}

__replicate-component() #60
{
  local Source="$1" TargetBase="$2" Target="$2/$1"
  [ -e "$Source" ] && { echo >&2 "*** replicate-component: Source='$Source' -- empty / non-existing argument; return"; return 60; }
  [ -e "$TargetBase" ] && { echo >&2 "*** replicate-component: TargetBase='$TargetBase' -- empty / non-existing argument; return"; return 60; }

  local src_type="$(__file-type "$Source")"
  case "$src_type" in
    (directory)
        if [ -e "$Target" ]; then
          [ -d "$Target" ]  ||
          {
            echo >&2 "*** replicate-component: '$Target' -- already exist; mismatched type: not a directory; return"
            return 68
          }
        else
          sudo mkdir -v "$Target"  ||
          {
            echo >&2 "*** replicate-component: '$Target' -- cannot create directory; return"
            return 61
          }
        fi
        ;;&
    (regular\ file)
        if [ -e "$Target" ]; then
          [ -f "$Target" ]  ||
          {
            echo >&2 "*** replicate-component: '$Target' -- already exist; mismatched type: not a file; return"
            return 68
          }
        else
          sudo dd status=none if=/dev/null of="$Target"  ||
          {
            echo >&2 "*** replicate-component: '$Target' -- cannot create file; return"
            return 61
          }
        fi
        ;;&
    (directory | regular\ file)
        sudo chown -v --reference="$Source" "$Target"
        sudo chmod -v --reference="$Source" "$Target"
        sudo chcon -v --reference="$Source" "$Target"
        ;;
    (symbolic\ link\ *)
        if [ -e "$Target" ]; then
          local deref_src_type="${src_type##symbolyc link / }"
          if [ -n "$deref_src_type" ]; then
            local tgt_type="$(__file-type "$Target")"
            local deref_tgt_type="${tgt_type##symbolic link / }"
            if [ -n "$deref_tgt_type" ]; then
              [ "$deref_tgt_type" = "$deref_src_type" ]  ||
              {
                echo >&2 "*** replicate-component: '$Target' -- already exist; mismatched type: not a $deref_src_type; return"
                return 68
              }
            fi
          fi
        else
          sudo cp -v -P --preserve=all -T "$Source" "$Target"  ||
          {
            echo >&2 "*** replicate-component: '$Target' -- cannot copy symlink; return"
            return 61
          }
        fi
        ;;
    (*)
        echo >&2 "*** replicate-component: '$Source' -- unsupported source type: $src_type; return"
        return 69
        ;;
  esac
  return 0
}
__replicate() #60
{
  local Source="$1" NewRoot="$2" Target="$NewRoot/$Source"
  [ -e "$Source" ] && { echo >&2 "*** replicate: Source='$Source' -- empty / non-existing argument; return"; return 60; }
  [ -e "$NewRoot" ] && { echo >&2 "*** replicate: NewRoot='$NewRoot' -- empty / non-existing argument; return"; return 60; }

  ## replicate path to Source
  local src="" src_type="" tgt="$NewRoot" C=""
  while IFC='' read -r -d '/' C || [ "$C" ]; do
    [ -z "$C" ] && continue;
    [ "$C" = "." ] && { src="${src:-.}"; continue; }
    src="$src/$C"
    tgt="$tgt/$C"
    [ "$C" = ".." ] && continue

    if [ -e "$tgt" ]; then
      [ -d "$tgt" ]  ||
      {
        echo >&2 "*** replicate: '$tgt' -- component already exists; mismatched type: not a directory; abort"
        return 68
      }
    else
      src_type="$(__file-type "$src")"
      case "$src_type" in
        (directory)
            sudo mkdir -v "$tgt"  ||
            {
              echo >&2 "*** replicate: '$tgt' -- cannot create directory; abort"
              return 61
            }
            ;;
        (symbolic\ link\ /\ directory)
            sudo cp -v -P --preserve=all -T "$src" "$tgt"  ||
            {
              echo >&2 "*** replicate: '$tgt' -- cannot copy symlink; abort"
              return 61
            }
            [ -d "$tgt" ]  ||
            {
              echo >&2 "*** replicate: '$tgt' -- component appears to be a dangling symlink; create a directory instead of symlink copying"
              sudo rm "$tgt"
              sudo mkdir -v "$tgt"  ||
              {
                echo >&2 "*** replicate: '$tgt' -- cannot create directory; abort"
                return 61
              }
            }
            ;;
        (*)
            echo >&2 "*** replicate: '$src' -- unexpected component type: $src_type; abort"
            return 69
            ;;
      esac
    fi
    sudo chown -v --reference="$src" "$tgt"
    sudo chmod -v --reference="$src" "$tgt"
    sudo chcon -v --reference="$src" "$tgt"
  done < <$(dirname "$Source")

  ## replicate Source itself
  local src_type="$(__file-type "$Source")"
  case "$src_type" in
    (directory)
        if [ -e "$Target" ]; then
          [ -d "$Target" ]  ||
          {
            echo >&2 "*** replicate: '$Target' -- target already exists; mismatched type: not a directory; abort"
            return 66
          }
        else
          sudo mkdir -v "$Target"  ||
          {
            echo >&2 "*** replicate: '$Target' -- cannot create directory; abort"
            return 62
          }
        fi
        ;;
    (regular\ file)
        if [ -e "$Target" ]; then
          [ -f "$Target" ]  ||
          {
            echo >&2 "*** replicate: '$Target' -- target already exists; mismatched type: not a file; abort"
            return 66
          }
        else
          sudo dd status=none if=/dev/null of="$Target"  ||
          {
            echo >&2 "*** replicate: '$Target' -- cannot create file; abort"
            return 62
          }
        fi
        ;;
    (symbolic\ link\ /\ *)
        if [ -e "$Target" ]; then
          local deref_src_type="${src_type##symbolyc link / }"
          if [ -n "$deref_src_type" ]; then
            local tgt_type="$(__file-type "$Target")" deref_tgt_type="${tgt_type##symbolic link / }"
            if [ -n "$deref_tgt_type" ]; then
              [ "$deref_tgt_type" = "$deref_src_type" ]  ||
              {
                echo >&2 "*** replicate: '$Target' -- target already exists; mismatched type: not a $deref_src_type; abort"
                return 66
              }
            fi
          fi
        else
          sudo cp -v -P --preserve=all -T "$Source" "$Target"  ||
          {
            echo >&2 "*** replicate: '$Target' -- cannot copy symlink; abort"
            return 62
          }
        fi
        ;;
    (*)
        echo >&2 "*** replicate: '$Source' -- unsupported source type: $src_type; abort"
        return 69
        ;;
  esac
  sudo chown -v --reference="$Source" "$Target"
  sudo chmod -v --reference="$Source" "$Target"
  sudo chcon -v --reference="$Source" "$Target"

  return 0
}

dupmount()  #70
{
  local Source="$1" NewRoot="$2" Target="$NewRoot/$Source"
  local -i Opt_ro=$(($3&1))

  mountpoint -q "$Source"  ||
  {
    echo >&2 "*** dupmount: '$Source' -- not a mountpoint; return"
    return 71
  }

  local src_type="$(__file-type "$Source")" deref_src_type="${src_type##symbolic link / }"
  case "$deref_src_type" in
    (directory | regular\ file)
        if [ -e "$Target" ]; then
          local tgt_type="$(__file-type "$Target")" deref_tgt_type="${tgt_type##symbolic link / }"
          [ "$deref_tgt_type" = "$deref_src_type" ]  ||
          {
            echo >&2 "*** dupmount: '$Target' -- cannot mount mismatched type: not a $deref_src_type; return"
            return 72
          }
          mountpoint -q "$Target" && echo >&2 "*** dupmount: '$Target' -- is a mountpoint; will be over-mounted"
        else
          __replicate "$Source" "$NewRoot"  ||
          {
            echo >&2 "*** dupmount: '$Target' -- cannot create mountpoint; abort"
            return 73
          }
        fi
        ;;&
    (directory)
        if sudo mount -v --bind "$SOURCE" "$TARGET"; then
          [ "$opt_ro" -ne 0 ] && sudo mount -v -o remount,ro,bind "$SOURCE" "$TARGET"
          if [ "$opt_recursive" -ne 0 ]; then
            findmnt --raw --noheadings --output TARGET --submounts --uniq '/'  |
            LC_ALL=C sort  |
            while IFS='' read -r src; do
              [ "$src" = "$SOURCE" ] && continue
              [ "${src:0:${#SOURCE}}" = "$SOURCE" ] && __do-bind "$src" "$CHROOT" $opt_ro
            done
          fi
        else
          return 51
        fi
        ;;
    (regular\ file)
        if sudo mount -v --bind "$SOURCE" "$TARGET"; then
          [ "$opt_ro" -ne 0 ] && sudo mount -v -o remount,ro,bind "$SOURCE" "$TARGET"
        else
          return 52
        fi
        ;;
    (*)
        echo >&2 "*** dupmount: '$Source' -- unexpected source type: $deref_src_type; return"
        return 60
        ;;
  esac
  return 0
}

__print-bind-mounts()  # print a summary of the existing bind-mounts for NEW_ROOT
{
  findmnt --list --output TARGET,SOURCE,PROPAGATION,FSTYPE,OPTIONS  |
  gawk -v P="$(realpath -q -e "$NEW_ROOT")" -e 'NR==1 {print; next}; index($0, P) {print | "LC_ALL=C sort"}'
}

__chtoor-setup() #30
{
  ## create the setup establishment marker file
  dd status=none if=/dev/null of="$CHTOOR_DIR/$CHTOOR_MARKER"  ||
  {
    echo >&2 "*** chtoor-setup: '$CHTOOR_DIR/$CHTOOR_MARKER' -- cannot create file; return"
    return 31
  }

  ## create the new root directory
  if [ -e "$NEW_ROOT" ]; then
    [ -d "$NEW_ROOT" ] || { echo >&2 "*** chtoor-setup: '$NEW_ROOT' -- not a directory; return"; return 32; }
    mountpoint -q "$NEW_ROOT" && { echo >&2 "*** chtoor-setup: '$NEW_ROOT' -- is a mountpoint; return"; return 32; }
    __is-same "$NEW_ROOT" "/" && { echo >&2 "*** chtoor-setup: '$NEW_ROOT' -- is the current root; return"; return 32; }
  else
    mkdir -v "$NEW_ROOT" || { echo >&2 "*** chtoor-setup: '$NEW_ROOT' -- cannot create directory; return"; return 32; }
  fi

  ## do setup the new root hierarchy
  local method='' item_methods='' item=''
  while IFS='' read -r item; do
    [ -z "$item" ] && continue
    item_methods="${SETUP[$item]}"
    method="${item_methods%%!*}"
    [ -z "$method" ] && continue
    echo "[$item]='$method'"
    "$method" "$item"  ||
    {
      local -i err_code=$?
      echo >&2 "*** chtoor-setup: $method error $err_code; abort"
      return "$err_code";
    }
  done < <(IFS=$'\n'; LC_ALL=C sort <<<"${!SETUP[*]}")

  ## create a marker file to visually distiguish the new root hierarchy
  if [ ! __is-same "$NEW_ROOT" "/" -a -w "$NEW_ROOT" ]; then
    sudo dd status=none if=/dev/null of="$NEW_ROOT/$CHTOOR_MARKER"  &&
    sudo chown "$USER:$USER" "$NEW_ROOT/$CHTOOR_MARKER"
  fi

  ##
  __print-bind-mounts
  return 0
}

__chtoor-go() #40
{
  [ -f "$CHTOOR_DIR/$CHTOOR_MARKER" ]  ||
  __chtoor-setup  &&
  {
    sudo chroot -- "$NEW_ROOT" su "$USER" "$RUN"
  }
}

__chtoor-undo() #50
{
  [ -d "$NEW_ROOT" ] || { echo >&2 "*** chtoor-undo: '$NEW_ROOT' -- not a directory; return"; return 51; }
  [ "$(realpath -q -e "$NEW_ROOT")" = "/" ] && { echo >&2 "*** chtoor-undo: '$NEW_ROOT' -- is the current root mountpoint; return"; return 51; }

  ## undo setup for new root hierarchy
  local method='' item_methods='' item=''
  while IFS='' read -r item; do
    [ -z "$item" ] && continue
    item_methods="${SETUP[$item]}"
    method="${item_methods##*!}"
    [ -z "$method" ] && continue
    if [ "$method" = "$item_methods" ]; then
      method="undo-$method"
      declare -F "$method" >/dev/null || continue  # skip non-existing default corresponding undo method
    fi
    echo "[$item]='$method'"
    "$method" "$item"  ||
    {
      local -i err_code=$?
      echo >&2 "*** chtoor-undo: $method error $err_code; abort"
      return "$err_code";
    }
  done < <(IFS=$'\n'; LC_ALL=C sort <<<"${!SETUP[*]}")

  ##
  [ -w "$NEW_ROOT" -a -f "$NEW_ROOT/$CHTOOR_MARKER" ] && rm -v "$NEW_ROOT/$CHTOOR_MARKER"
  __print-bind-mounts

  ## remove the setup establishment marker file
  rm -v "$CHTOOR_DIR/$CHTOOR_MARKER"
}


exit


is-root()  { [ "$(realpath -q -e "$1")" = "/" ]; }
is-same()
{
  local LHS="$(realpath -q -e "$1")" RHS="$(realpath -q -e "$2")"
  [ -n "$LHS" -a -n "$RHS" -a "$LHS" = "$RHS" ]
}


__do-bind()
{
  local SOURCE="$1" CHROOT="$2" TARGET="$2/$1"
  [ -n "$SOURCE" ] || return 1
  [ -d "$CHROOT" ] || return 2
  ! is-root "$CHROOT" || return 3
  ! mountpoint -q "$TARGET" || return 4
  ! is-same "$SOURCE" "$TARGET" || return 6

  local -i opt_ro=$(($3&1)) opt_recursive=$(($3&2))

  local source_type="$(stat --printf=%F "$SOURCE")"
  case "$source_type" in
    (directory)
        if [ ! -d "$TARGET" ]; then
          [ ! -e "$TARGET" ]  &&
          {
            sudo mkdir -v -p "$TARGET"  &&
            sudo chown -v "$USER:$USER" "$TARGET"
          }  ||
          return 41
        fi
        if sudo mount -v --bind "$SOURCE" "$TARGET"; then
          [ "$opt_ro" -ne 0 ] && sudo mount -v -o remount,ro,bind "$SOURCE" "$TARGET"
          if [ "$opt_recursive" -ne 0 ]; then
            findmnt --raw --noheadings --output TARGET --submounts --uniq '/'  |
            LC_ALL=C sort  |
            while IFS='' read -r src; do
              [ "$src" = "$SOURCE" ] && continue
              [ "${src:0:${#SOURCE}}" = "$SOURCE" ] && __do-bind "$src" "$CHROOT" $opt_ro
            done
          fi
        else
          return 51
        fi
        ;;
    (regular\ file)
        if [ ! -f "$TARGET" ]; then
          [ ! -e "$TARGET" ]  &&
          {
            sudo dd status=none if=/dev/null of="$TARGET"  &&
            sudo chown -v "$USER:$USER" "$TARGET"
          }  ||
          return 42
        fi
        if sudo mount -v --bind "$SOURCE" "$TARGET"; then
          [ "$opt_ro" -ne 0 ] && sudo mount -v -o remount,ro,bind "$SOURCE" "$TARGET"
        else
          return 52
        fi
        ;;
    (symbolic\ link)
        sudo cp -v -P --preserve=all -T "$SOURCE" "$TARGET" || return 43
        ;;
    (*)
        return 5
        ;;
  esac
  return 0
}
bind()  { __do-bind "$1" "$2" 0; }
bind-ro()  { __do-bind "$1" "$2" 1; }
rbind()  { __do-bind "$1" "$2" 2; }
rbind-ro()  { __do-bind "$1" "$2" 3; }

__undo-bind()
{
  local SOURCE="$1" CHROOT="$2" TARGET="$2/$1"
  [ -n "$SOURCE" ] || return 1
  [ -d "$CHROOT" ] || return 2
  ! is-root "$CHROOT" || return 3
  ! is-same "$SOURCE" "$TARGET" || return 6

  shift 2

  local source_type="$(stat --printf=%F "$SOURCE")"
  case "$source_type" in
    (directory | regular\ file)
        if mountpoint "$TARGET"; then
          sudo umount -v "$@" "$TARGET"  ||
          {
            sudo fuser -v -m "$TARGET"
            return 4
          }
        fi
        ;;
    (symbolic\ link)
        if [ -L "$TARGET" ]; then
          sudo rm -v "$TARGET"  || return 43
        else
          echo >&2 "__undo-bind: '$TARGET' is not a symbolic link"
        fi
        ;;
    (*)
        return 5
        ;;
  esac
}
undo-bind()  { __undo-bind "$1" "$2"; }
undo-bind-ro()  { __undo-bind "$1" "$2"; }
undo-rbind()  { __undo-bind "$1" "$2" -R; }
undo-rbind-ro()  { __undo-bind "$1" "$2" -R; }


__clone_target_path()
{
  local SOURCE="$1" CHROOT="$2" TARGET="$2/$1"
  [ -n "$SOURCE" ] || return 1
  [ -d "$CHROOT" ] || return 2
  ! is-root "$CHROOT" || return 3
  ! mountpoint -q "$TARGET" || return 4
  ! is-same "$SOURCE" "$TARGET" || return 5

  local src="" tgt="$CHROOT" pth=""
  while IFC='' read -r -d '/' pth || [ "$pth" ]; do
    [ -z "$pth" ] && continue;
    [ "$pth" = "." ] && { src="${src:-.}"; continue; }
    src="$src/$pth"
    tgt="$tgt/$pth"
    [ "$pth" = ".." ] && continue

    if [ -e "$src" -a ! -d "$src" ]; then
      echo >&2 "$0: '$tgt' -- $(stat --printf=%F "$src") in the path to '$TARGET'"
      return 11
    fi
    if mountpoint -q "$tgt"; then
      echo >&2 "$0: '$tgt' -- mount point in the path to '$TARGET'"
      return 14
    fi

    sudo mkdir -v -p "$tgt" || return 10
    sudo chown -v --reference="$src" "$tgt"
    sudo chmod -v --reference="$src" "$tgt"
    sudo chcon -v --reference="$src" "$tgt"
  done < <(dirname "$SOURCE")
}

__create()
{
  local SOURCE="$1" CHROOT="$2" TARGET="$2/$1"
  [ -n "$SOURCE" ] || return 1
  [ -d "$CHROOT" ] || return 2
  ! is-root "$CHROOT" || return 3
  ! mountpoint -q "$TARGET" || return 4
  ! is-same "$SOURCE" "$TARGET" || return 5

  local source_type="$(stat --printf=%F "$SOURCE")"
  case "$source_type" in
    (directory)
        __clone_target_path "$SOURCE" "$CHROOT" || return
        sudo mkdir -v -p "$TARGET" || return 41
        sudo chown -v --reference="$SOURCE" "$TARGET"
        sudo chmod -v --reference="$SOURCE" "$TARGET"
        sudo chcon -v --reference="$SOURCE" "$TARGET"
        ;;
    (regular\ file)
        __clone_target_path "$SOURCE" "$CHROOT" || return
        sudo dd status=none if=/dev/null of="$TARGET" || return 42;
        sudo chown -v --reference="$SOURCE" "$TARGET"
        sudo chmod -v --reference="$SOURCE" "$TARGET"
        sudo chcon -v --reference="$SOURCE" "$TARGET"
        ;;
    (symbolic\ link)
        __clone_target_path "$SOURCE" "$CHROOT" || return
        sudo cp -v -P --preserve=all -T "$SOURCE" "$TARGET" || return 43
        ;;
    (*)
        return 6
        ;;
  esac
}
create()  { __create "$1" "$2"; }
create-if-not-exist()  { [ -e "$2/$1" ] || __create "$1" "$2"; }


__copy()
{
  local SOURCE="$1" CHROOT="$2" TARGET="$2/$1"
  [ -n "$SOURCE" ] || return 1
  [ -d "$CHROOT" ] || return 2
  ! is-root "$CHROOT" || return 3
  ! mountpoint -q "$TARGET" || return 4
  ! is-same "$SOURCE" "$TARGET" || return 5

  shift 2

  local source_type="$(stat --printf=%F "$SOURCE")"
  case "$source_type" in
    (directory)
        __clone_target_path "$SOURCE" "$CHROOT" || return
        sudo cp -v --preserve=all -R "$@" -T "$SOURCE" "$TARGET" || return 41
        ;;
    (regular\ file)
        __clone_target_path "$SOURCE" "$CHROOT" || return
        sudo cp -v --preserve=all "$@" -T "$SOURCE" "$TARGET" || return 42
        ;;
    (symbolic\ link)
        __clone_target_path "$SOURCE" "$CHROOT" || return
        sudo cp -v -P --preserve=all "$@" -T "$SOURCE" "$TARGET" || return 43
        ;;
    (*)
        return 5
        ;;
  esac
}
copy()  { __copy "$1" "$2"; }
copy-if-not-exist()  { [ -e "$2/$1" ] || __copy "$1" "$2"; }
copy-update()  { __copy "$1" "$2" -u; }


chroot-setup()
{
  local CHROOT="$1"
  [ -d "$CHROOT" ] || return 1
  ! is-root "$CHROOT" || return 2
  ! mountpoint -q "$CHROOT" || return 3

  local source="" method=""
  for method in "${CHROOT_SETUP[@]}"; do
    method="${method%%!*}"
    [ -z "$method" ] && continue
    if ! declare -F "$method" >/dev/null; then
      echo >&2 "$0: unknown setup method -- '$method'"
      return 4
    fi
  done

  sudo dd status=none if=/dev/null of="$CHROOT/.chroot"  &&
  sudo chown "$USER:$USER" "$CHROOT/.chroot"  ||
  return 5

  while IFS='' read -r source; do
    [ -z "$source" ] && continue
    method="${CHROOT_SETUP[$source]%%!*}"
    [ -z "$method" ] && continue
    echo "[$source]: $method"
    "$method" "$source" "$CHROOT"  ||
    {
      local -i err_code=$?
      echo >&2 "$0: $method error $err_code"
      return "$err_code";
    }
    echo
  done < <(IFS=$'\n'; LC_ALL=C sort <<<"${!CHROOT_SETUP[*]}")

  findmnt --list  |
  sed -b -n -e '1{p; b;}; \'$'\x01'"${CHROOT}"$'\x01''p'  |
  awk -e 'NR>1 {print | "LC_ALL=C sort"; next}; NR==1'
}
chroot-undo()
{
  local CHROOT="$1"
  [ -d "$CHROOT" ] || return 1
  ! is-root "$CHROOT" || return 2
  ! mountpoint -q "$CHROOT" || return 3

  local source="" method=""
  for method in "${CHROOT_SETUP[@]}"; do
    method="${method##*!}"
    [ -z "$method" ] && continue
    method="undo-$method"
    if ! declare -F "$method" >/dev/null; then
      echo >&2 "$0: unknown undo method -- '$method'"
      return 4
    fi
  done

  while IFS='' read -r source; do
    [ -z "$source" ] && continue
    method="${CHROOT_SETUP[$source]##*!}"
    [ -z "$method" ] && continue
    method="undo-$method"
    echo "[$source]: $method"
    "$method" "$source" "$CHROOT"  ||
    {
      local -i err_code=$?
      echo >&2 "$0: $method error $err_code"
      return "$err_code";
    }
    echo
  done < <(IFS=$'\n'; LC_ALL=C sort <<<"${!CHROOT_SETUP[*]}")

  findmnt --list  |
  sed -b -n -e '1{p; b;}; \'$'\x01'"${CHROOT}"$'\x01''p'  |
  awk -e 'NR>1 {print | "LC_ALL=C sort"; next}; NR==1'

  rm -v "$CHROOT/.chroot"
}


chroot-go()
{
  local CHROOT="$1"
  [ -d "$CHROOT" ] || return 1
  ! is-root "$CHROOT" || return 2

  shift

  [ -f "$CHROOT/.chroot" ]  ||
  chroot-setup "$CHROOT"  &&
  {
    sudo chroot -- "$CHROOT" su "$USER" "$@"
  }
}



chroot-"$OPT_COMMAND" "$@"


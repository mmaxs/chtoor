#! /bin/bash

## DECLARATIONS

declare OPT_MODE="go"
declare OPT_CONFIG_FILE=""
while getopts "f:GSU" OPT; do
  case "$OPT" in
    f)  OPT_CONFIG_FILE="$OPTARG"
        if [ ! -f "$OPT_CONFIG_FILE" ]; then
          echo >&2 "*** config file: '$OPT_CONFIG_FILE' -- no such file; exit"
          exit 1
        fi
        ;;
    G)  OPT_MODE="go"
        ;;
    S)  OPT_MODE="setup"
        ;;
    U)  OPT_MODE="undo"
        ;;
   \?)  exit 1
        ;;
  esac
done
shift $((OPTIND-1))

declare CHTOOR_DIR="$1"  # the directory where to create the new root
[ -z "$CHTOOR_DIR" ] && { echo >&2 "*** CHTOOR_DIR: directory not specified; exit"; exit 2; }
[ -d "$CHTOOR_DIR" ] || { echo >&2 "*** CHTOOR_DIR: '$CHTOOR_DIR' -- not exist / not a directory; exit"; exit 2; }

declare NEW_ROOT="$CHTOOR_DIR/new_root"
declare OWN_DIR="$CHTOOR_DIR/own_files"
declare CHTOOR_MARKER=".chtoor"  # the file name to visually denote the new root environment establishment
# For quick recognizing that the new root environment setup has been performed (i.e. some bind
# mounts to NEW_ROOT are created) the CHTOOR_MARKER file is placed into CHTOOR_DIR.
# If after setup complete, the NEW_ROOT directory appears to be write enabled, and
# it does not appear to be bind-mounted to the current root directory, the CHTOOR_MARKER file is
# additionally created therein for the new root directory hierarchy can be distiguished in some visual
# way after switching into it.

declare USER="$(id -nu)"
declare RUN="bash -l"  # the command to run with the changed root directory
declare EXPORT=(DISPLAY)  # shell variables for export into new root environment
declare -A SETUP=(  # some minimal defaults to setup the NEW_ROOT directory hierarchy
    [/]=rbind-ro
    [/home/"$USER"]=own-create
    [/home/"$USER"/.bash_profile]=own-copy-missing
    [/home/"$USER"/.bashrc]=own-copy-missing
    [/home/"$USER"/.inputrc]=own-copy-missing
)


## SUBROUTINES -- GENERAL

__is-same-file()
{
  local LHS="$(realpath -q -e "$1")" RHS="$(realpath -q -e "$2")"
  [ -n "$LHS" -a -n "$RHS" ]  &&
  {
    test "$LHS" = "$RHS"  ||
    {
      LHS="$(stat --printf="%d:%i" "$LHS")"
      RHS="$(stat --printf="%d:%i" "$RHS")"
      test "$LHS" = "$RHS"
    }
  }
}
__is-same-or-descendant-file()
{
  local ancestor="$(realpath -q -e "$1")" descendant="$(realpath -q -e "$2")"
  __is-same-file "$ancestor" "$descendat" || [[ "$ancestor" == "$descendat"/* ]]
}

__file-type()
{
  local t=""
  while true; do
    test -d "$1" && { t="directory"; break; }
    test -f "$1" && { t="regular file"; break; }
    test -b "$1" && { t="block special"; break; }
    test -c "$1" && { t="character special"; break; }
    test -p "$1" && { t="named pipe"; break; }
    test -S "$1" && { t="socket"; break; }
    break;
  done
  test -L "$1" && t="symbolic link / $t"
  echo "$t"
}

__submounts()
{
  local Target="$(realpath -q -e "$1")"
  [ -n "$Target" ]  &&
  {
    findmnt --raw --noheadings --output TARGET --submounts --uniq  |
    LC_ALL=C sort  |
    gawk -v Target="$Target" -e '
        BEGIN { TargetStrLen=length(Target); Submount="" }
        $0==Target { next }
        index($0, Target)==1 && !Submount { Submount=$0; print substr($0, TargetStrLen+1); next }
        index($0, Target)==1 && Submount  { if (index($0, Submount)==1) next; else { Submount=$0; print substr($0, TargetStrLen+1) } }
    '
  }
}


__copy-file-attributes()
{
  local Source="$1" Target="$2" StatFormat="$3" ChAttrCmd="$4"
  [ -e "$Source" ] || { echo >&2 "*** replicate-file-attributes: Source='$Source' -- empty / non-existing argument; return"; return 1; }
  [ -e "$Target" ] || { echo >&2 "*** replicate-file-attributes: Target='$Target' -- empty / non-existing argument; return"; return 1; }
  [ -n "$StatFormat" ] || { echo >&2 "*** replicate-file-attributes: empty StatFormat argument; return"; return 1; }
  [ -n "$ChAttrCmd" ] || { echo >&2 "*** replicate-file-attributes: empty ChAttrCmd argument; return"; return 1; }

  local src_attrs="$(sudo stat --format="$StatFormat" "$Source" 2>/dev/null)"
  local tgt_attrs="$(sudo stat --format="$StatFormat" "$Target" 2>/dev/null)"

  [ "${src_attrs:-$Source}" != "${tgt_attrs:-$Target}" ]  &&
  sudo $ChAttrCmd -v --reference="$Source" "$Target"
}
__copy-file-permissions()  { __copy-file-attributes "$1" "$2" "%#05a" chmod; }
__copy-file-ownerships()  { __copy-file-attributes "$1" "$2" "%U:%G" chown; }
__copy-file-selinux-context()  { __copy-file-attributes "$1" "$2" "%C" chcon; }

__replicate-pathname()
{
  local Source="$1" NewRoot="$2"
  local Target="$NewRoot/$Source"
  [ -e "$Source" ] || { echo >&2 "*** replicate-pathname: Source='$Source' -- empty / non-existing argument; return"; return 60; }
  [ -d "$NewRoot" ] || { echo >&2 "*** replicate-pathname: NewRoot='$NewRoot' -- empty argument / not a directory; return"; return 60; }

  ## replicate path to Source
  local src="" src_type="" tgt="$NewRoot" C=""
  while IFC='' read -r -d '/' C || [ "$C" ]; do
    [ -z "$C" ] && continue;  # skip empty component (on sequences of slashes)
    [ "$C" = "." ] && { src="${src:-.}"; continue; }  # remove a single dot - the alias for a current directory
    src="$src/$C"
    tgt="$tgt/$C"
    [ "$C" = ".." ] && continue  # continue on two dots - the alias for a parent directory

    if [ -e "$tgt" ]; then
      [ -d "$tgt" ]  ||
      {
        echo >&2 "*** replicate-pathname: '$tgt' -- target path component exists and is of mismatched type: not a directory; abort"
        return 68
      }
    else
      src_type="$(__file-type "$src")"
      case "$src_type" in
        (directory)
            sudo mkdir -v "$tgt"  ||
            {
              echo >&2 "*** replicate-pathname: '$tgt' -- cannot create directory; abort"
              return 61
            }
            ;;
        (symbolic\ link\ /\ directory)
            sudo cp -v -P --preserve=all -T "$src" "$tgt"  ||
            {
              echo >&2 "*** replicate-pathname: '$tgt' -- cannot copy symlink; abort"
              return 61
            }
            [ -d "$tgt" ]  ||
            {
              echo >&2 "*** replicate-pathname: '$tgt' -- path component appears to be a dangling symlink; create directory instead of symlink copying"
              sudo rm "$tgt"
              sudo mkdir -v "$tgt"  ||
              {
                echo >&2 "*** replicate-pathname: '$tgt' -- cannot create directory; abort"
                return 61
              }
            }
            ;;
        (*)
            echo >&2 "*** replicate-pathname: '$src' -- unexpected path component type: $src_type; abort"
            return 69
            ;;
      esac
    fi
    __copy-file-permissions "$src" "$tgt"  # sudo chmod -v --reference="$src" "$tgt"
    __copy-file-ownerships "$src" "$tgt"  # sudo chown -v --reference="$src" "$tgt"
    __copy-file-selinux-context "$src" "$tgt"  # sudo chcon -v --reference="$src" "$tgt"
  done < <(dirname "$Source")

  ## replicate Source itself
  local src_type="$(__file-type "$Source")"
  case "$src_type" in
    (directory)
        if [ -e "$Target" ]; then
          [ -d "$Target" ]  ||
          {
            echo >&2 "*** replicate-pathname: '$Target' -- target already exists and is of mismatched type: not a directory; abort"
            return 66
          }
        else
          sudo mkdir -v "$Target"  ||
          {
            echo >&2 "*** replicate-pathname: '$Target' -- cannot create directory; abort"
            return 62
          }
        fi
        ;;&
    (regular\ file)
        if [ -e "$Target" ]; then
          [ -f "$Target" ]  ||
          {
            echo >&2 "*** replicate-pathname: '$Target' -- target already exists and is of mismatched type: not a file; abort"
            return 66
          }
        else
          sudo dd status=none if=/dev/null of="$Target"  ||
          {
            echo >&2 "*** replicate-pathname: '$Target' -- cannot create file; abort"
            return 62
          }
        fi
        ;;&
    (directory | regular\ file)
        __copy-file-permissions "$Source" "$Target"  # sudo chmod -v --reference="$Source" "$Target"
        __copy-file-ownerships "$Source" "$Target"  # sudo chown -v --reference="$Source" "$Target"
        __copy-file-selinux-context "$Source" "$Target"  # sudo chcon -v --reference="$Source" "$Target"
        ;;
    (symbolic\ link\ /\ *)
        if [ -e "$Target" ]; then
          local deref_src_type="${src_type##symbolyc link / }"
          if [ -n "$deref_src_type" ]; then
            local tgt_type="$(__file-type "$Target")"
            local deref_tgt_type="${tgt_type##symbolic link / }"
            if [ -n "$deref_tgt_type" ]; then
              [ "$deref_tgt_type" = "$deref_src_type" ]  ||
              {
                echo >&2 "*** replicate-pathname: '$Target' -- target already exists and is of mismatched type: not a $deref_src_type; abort"
                return 66
              }
            fi
          fi
        else
          sudo cp -v -P --preserve=all -T "$Source" "$Target"  ||
          {
            echo >&2 "*** replicate-pathname: '$Target' -- cannot copy symlink; abort"
            return 62
          }
          if [ -e "$Target" ]; then
            __copy-file-permissions "$Source" "$Target"  # sudo chmod -v --reference="$Source" "$Target"
            __copy-file-ownerships "$Source" "$Target"  # sudo chown -v --reference="$Source" "$Target"
            __copy-file-selinux-context "$Source" "$Target"  # sudo chcon -v --reference="$Source" "$Target"
          fi
        fi
        ;;
    (*)
        echo >&2 "*** replicate-pathname: '$Source' -- unsupported source type: $src_type; abort"
        return 69
        ;;
  esac

  return 0
}


## SUBROUTINES -- SETUP METHODS

__dupmount()
{
  local Source="$1" NewRoot="$2"
  local Target="$NewRoot/$Source"
  local -i OptRO=$((${3:-0}&1)) OptRecursive=$((${3:-0}&2))
  [ -e "$Source" ] || { echo >&2 "*** dupmount: Source='$Source' -- empty / non-existing argument; return"; return 70; }
  [ -d "$NewRoot" ] || { echo >&2 "*** dupmount: NewRoot='$NewRoot' -- empty argument / not a directory; return"; return 70; }

  mountpoint -q "$Source"  ||
  {
    echo >&2 "*** dupmount: '$Source' -- source is not a mountpoint; return"
    return 71
  }

  local src_type="$(__file-type "$Source")"
  local deref_src_type="${src_type##symbolic link / }"
  case "$deref_src_type" in
    (directory | regular\ file)
        if [ -e "$Target" ]; then
          local tgt_type="$(__file-type "$Target")"
          local deref_tgt_type="${tgt_type##symbolic link / }"
          [ "$deref_tgt_type" = "$deref_src_type" ]  ||
          {
            echo >&2 "*** dupmount: '$Target' -- cannot mount to existing target of mismatched type: not a $deref_src_type; return"
            return 72
          }
          mountpoint -q "$Target" && echo >&2 "*** dupmount: '$Target' -- target is a mountpoint; will be over-mounted"
        else
          __replicate-pathname "$Source" "$NewRoot"  ||
          {
            echo >&2 "*** dupmount: '$Target' -- cannot create mountpoint; abort"
            return 73
          }
        fi
        local -A mp_info
        eval mp_info=("$(findmnt --pairs --output FSTYPE,OPTIONS,SOURCE,TARGET --uniq "$Source" | sed -e 's/\(^\|\s\)\([^=]\+\)=/\1[\2]=/g')")
        local mp_src="${mp_info[SOURCE]%%\[/*\]}" mp_tgt="${mp_info[TARGET]}" mp_opts="${mp_info[OPTIONS]}"
        if [ "$mp_src" != "${mp_info[SOURCE]}" ]; then
          ## bind mount
          mp_src="${mp_info[SOURCE]:${#mp_src}+1:-1}"  # extract bind mount source
          __is-same-file "$mp_src" "$Target" && { echo "--- dupmount: skip bind mounting the file to itself"; return 0; }
          echo "mount --bind '$mp_src' '$Target'"
          sudo mount -v --bind "$mp_src" "$Target"
          [ $? -eq 0 ] || return 77
          echo "mount --make-slave '$Target'"
          sudo mount -v --make-slave "$Target"
        else
          ## set the 'ro' mount option early because some 'rw'-mounted filesystems become 'busy' immediately
          [ "$OptRO" -ne 0 ] && mp_opts="$(sed -e 's/^rw,/ro,/; s/,rw,/,ro,/; s/,rw$/,ro/' <<<"$mp_opts")"
          echo "mount -t '${mp_info[FSTYPE]}' -o '$mp_opts' '$mp_src' '$Target'"
          sudo mount -v -t "${mp_info[FSTYPE]}" -o "$mp_opts" "$mp_src" "$Target"
          [ $? -eq 0 ] || return 77
        fi
        if [ "$OptRecursive" -ne 0 ]; then
          local -a submounts
          eval submounts=("$(__submounts "$Source")")
          if [ ${#submounts} -ne 0 ]; then
            local sub_mp=''
            echo "--- dupmount: [$Source] submounts:"
            for sub_mp in "${submounts[@]}"; do echo "[/$sub_mp]"; done
            echo "---"
            if [[ "$mp_opts" =~ (^|,)ro(,|$) ]]; then
              ## make sure that submount points exist on read-only mounted file system; if don't, replicate them
              for sub_mp in "${submounts[@]}"; do
                [ -e "$Target/$sub_mp" ] ||
                {
                  sudo mount -o remount,rw "$Target"
                  for sub_mp in "${submounts[@]}"; do
                    [ -e "$Target/$sub_mp" ] || __replicate-pathname "$Source/$sub_mp" "$NewRoot"
                  done
                  sudo mount -o remount,ro "$Target"
                  break
                }
              done
            fi
            for sub_mp in "${submounts[@]}"; do
              if __is-same-or-descendant-file "$NewRoot" "$Source/$sub_mp"; then
                echo "--- dupmount: [$Source/$sub_mp] -- skip self-recursion mount"
                continue
              fi
              echo "--- dupmount: [$Source/$sub_mp]"
              __dupmount "$Source/$sub_mp" "$NewRoot" "$((2|$OptRO))"
            done
          fi
        fi
        if [ "$OptRO" -ne 0 ]; then
          if [ "$mp_src" != "${mp_info[SOURCE]}" ]; then
            echo "mount -o remount,ro,bind '$mp_src' '$Target'"
            sudo mount -v -o remount,ro,bind "$mp_src" "$Target"
          else
            echo "mount -o remount,ro '$Target'"
            sudo mount -v -o remount,ro "$Target"
          fi
          [ $? -eq 0 ] || return 78
        fi
        ;;
    (*)
        echo >&2 "*** dupmount: '$Source' -- unexpected source type: $deref_src_type; return"
        return 79
        ;;
  esac
  return 0
}
dupmount()      { __dupmount "$1" "$NEW_ROOT" 0; return 0; }
dupmount-ro()   { __dupmount "$1" "$NEW_ROOT" 1; return 0; }
rdupmount()     { __dupmount "$1" "$NEW_ROOT" 2; return 0; }
rdupmount-ro()  { __dupmount "$1" "$NEW_ROOT" 3; return 0; }

__undo-dupmount()
{
  local Source="$1" NewRoot="$2"
  local Target="$NewRoot/$Source"
  local -i OptRO=$((${3:-0}&1)) OptRecursive=$((${3:-0}&2))
  [ -e "$Source" ] || { echo >&2 "*** undo-dupmount: Source='$Source' -- empty / non-existing argument; return"; return 70; }
  [ -d "$NewRoot" ] || { echo >&2 "*** undo-dupmount: NewRoot='$NewRoot' -- empty argument / not a directory; return"; return 70; }

  mountpoint -q "$Target"  ||
  {
    echo >&2 "*** undo-dupmount: '$Target' -- not a mountpoint; skipped"
    return 0
  }

  echo "umount -R '$Target'"
  sudo umount -v -R "$Target"
}
undo-dupmount()      { __undo-dupmount "$1" "$NEW_ROOT" 0; }
undo-dupmount-ro()   { __undo-dupmount "$1" "$NEW_ROOT" 1; }
undo-rdupmount()     { __undo-dupmount "$1" "$NEW_ROOT" 2; }
undo-rdupmount-ro()  { __undo-dupmount "$1" "$NEW_ROOT" 3; }


__bind()
{
  local Source="$1" NewRoot="$2"
  local Target="$NewRoot/$Source"
  local -i OptRO=$((${3:-0}&1)) OptRecursive=$((${3:-0}&2))
  [ -e "$Source" ] || { echo >&2 "*** bind: Source='$Source' -- empty / non-existing argument; return"; return 70; }
  [ -d "$NewRoot" ] || { echo >&2 "*** bind: NewRoot='$NewRoot' -- empty argument / not a directory; return"; return 70; }

  __is-same-file "$Source" "$Target" && { echo "--- bind: skip mounting the file to itself"; return 0; }

  local src_type="$(__file-type "$Source")"
  local deref_src_type="${src_type##symbolic link / }"
  case "$deref_src_type" in
    (directory | regular\ file)
        if [ -e "$Target" ]; then
          local tgt_type="$(__file-type "$Target")"
          local deref_tgt_type="${tgt_type##symbolic link / }"
          [ "$deref_tgt_type" = "$deref_src_type" ]  ||
          {
            echo >&2 "*** bind: '$Target' -- cannot mount to existing target of mismatched type: not a $deref_src_type; return"
            return 72
          }
          mountpoint -q "$Target" && echo >&2 "*** bind: '$Target' -- target is a mountpoint; will be over-mounted"
        else
          __replicate-pathname "$Source" "$NewRoot"  ||
          {
            echo >&2 "*** bind: '$Target' -- cannot create mountpoint; abort"
            return 73
          }
        fi
        echo "mount --bind '$Source' '$Target'"
        sudo mount -v --bind "$Source" "$Target"
        [ $? -eq 0 ] || return 77
        echo "mount --make-slave '$Target'"
        sudo mount -v --make-slave "$Target"
        if [ "$OptRO" -ne 0 ]; then
          echo "mount -o remount,ro,bind '$Source' '$Target'"
          sudo mount -v -o remount,ro,bind "$Source" "$Target"
          [ $? -eq 0 ] || return 78
        fi
        ;;&
    (directory)
        if [ "$OptRecursive" -ne 0 ]; then
          local -a submounts
          eval submounts=("$(__submounts "$Source")")
          if [ ${#submounts} -ne 0 ]; then
            local sub_mp=''
            echo "--- bind: [$Source] submounts:"
            for sub_mp in "${submounts[@]}"; do echo "[/$sub_mp]"; done
            echo "---"
            for sub_mp in "${submounts[@]}"; do
              if __is-same-or-descendant-file "$NewRoot" "$Source/$sub_mp"; then
                echo "--- bind: [$Source/$sub_mp] -- skip self-recursion mount"
                continue
              fi
              echo "--- bind: [$Source/$sub_mp]"
              __bind "$Source/$sub_mp" "$NewRoot" "$((2|$OptRO))"
            done
          fi
        fi
        ;;
    (*)
        echo >&2 "*** bind: '$Source' -- unexpected source type: $deref_src_type; return"
        return 79
        ;;
  esac
  return 0
}
bind()      { __bind "$1" "$NEW_ROOT" 0; return 0; }
bind-ro()   { __bind "$1" "$NEW_ROOT" 1; return 0; }
rbind()     { __bind "$1" "$NEW_ROOT" 2; return 0; }
rbind-ro()  { __bind "$1" "$NEW_ROOT" 3; return 0; }

__undo-bind()
{
  local Source="$1" NewRoot="$2"
  local Target="$NewRoot/$Source"
  local -i OptRO=$((${3:-0}&1)) OptRecursive=$((${3:-0}&2))
  [ -e "$Source" ] || { echo >&2 "*** undo-bind: Source='$Source' -- empty / non-existing argument; return"; return 70; }
  [ -d "$NewRoot" ] || { echo >&2 "*** undo-bind: NewRoot='$NewRoot' -- empty argument / not a directory; return"; return 70; }

  mountpoint -q "$Target"  ||
  {
    echo >&2 "*** undo-bind: '$Target' -- not a mountpoint; skipped"
    return 0
  }

  echo "umount -R '$Target'"
  sudo umount -v -R "$Target"
}
undo-bind()      { __undo-bind "$1" "$NEW_ROOT" 0; }
undo-bind-ro()   { __undo-bind "$1" "$NEW_ROOT" 1; }
undo-rbind()     { __undo-bind "$1" "$NEW_ROOT" 2; }
undo-rbind-ro()  { __undo-bind "$1" "$NEW_ROOT" 3; }


__own()
{
  local OwnDir="$1" Origin="$2" NewRoot="$3"
  local Source="$OwnDir/$Origin" Target="$NewRoot/$Origin"
  [ -d "$OwnDir" ] || { echo >&2 "*** own: OwnDir='$OwnDir' -- empty argument / not a directory; return"; return 70; }
  [ -e "$Origin" ] || { echo >&2 "*** own: Origin='$Origin' -- empty / non-existing argument; return"; return 70; }
  [ -d "$NewRoot" ] || { echo >&2 "*** own: NewRoot='$NewRoot' -- empty argument / not a directory; return"; return 70; }

  [ -e "$Source" ] || { echo >&2 "*** own: '$Source' -- non-existing source; return"; return 71; }
  __is-same-file "$Source" "$Target" && { echo "--- own: skip mounting the file to itself"; return 0; }

  local src_type="$(__file-type "$Source")"
  local deref_src_type="${src_type##symbolic link / }"
  case "$deref_src_type" in
    (directory | regular\ file)
        if [ -e "$Target" ]; then
          local tgt_type="$(__file-type "$Target")"
          local deref_tgt_type="${tgt_type##symbolic link / }"
          [ "$deref_tgt_type" = "$deref_src_type" ]  ||
          {
            echo >&2 "*** own: '$Target' -- cannot bind to existing target of mismatched type: not a $deref_src_type; return"
            return 72
          }
          mountpoint -q "$Target" && echo >&2 "*** own: '$Target' -- target is a mountpoint; will be over-mounted"
        else
          local osrc_type="$(__file-type "$Origin")"
          local deref_osrc_type="${osrc_type##symbolic link / }"
          [ "$deref_osrc_type" = "$deref_src_type" ]  ||
          {
            echo >&2 "*** own: Origin='$Origin' and Source='$Source' are of mismatched types; return"
            return 73
          }
          __replicate-pathname "$Origin" "$NewRoot"  ||
          {
            echo >&2 "*** own: '$Target' -- cannot create mountpoint; abort"
            return 74
          }
        fi
        # __copy-file-permissions "$Origin" "$Source"
        # __copy-file-ownerships "$Origin" "$Source"
        # __copy-file-selinux-context "$Origin" "$Source"
        echo "mount --bind '$Source' '$Target'"
        sudo mount -v --bind "$Source" "$Target"
        [ $? -eq 0 ] || return 77
        echo "mount --make-slave '$Target'"
        sudo mount -v --make-slave "$Target"
        ;;
    (*)
        echo >&2 "*** own: '$Source' -- unexpected source type: $deref_src_type; return"
        return 70
        ;;
  esac
  return 0
}
own() { __own "$OWN_DIR" "$1" "$NEW_ROOT"; }

__undo-own()
{
  local OwnDir="$1" Origin="$2" NewRoot="$3"
  local Source="$OwnDir/$Origin" Target="$NewRoot/$Origin"
  [ -d "$OwnDir" ] || { echo >&2 "*** own: OwnDir='$OwnDir' -- empty argument / not a directory; return"; return 70; }
  [ -e "$Origin" ] || { echo >&2 "*** own: Origin='$Origin' -- empty / non-existing argument; return"; return 70; }
  [ -d "$NewRoot" ] || { echo >&2 "*** own: NewRoot='$NewRoot' -- empty argument / not a directory; return"; return 70; }

  mountpoint -q "$Target"  ||
  {
    echo >&2 "*** undo-own: '$Target' -- not a mountpoint; skipped"
    return 0
  }

  echo "umount -R '$Target'"
  sudo umount -v -R "$Target"
}
undo-own() { __undo-own "$OWN_DIR" "$1" "$NEW_ROOT"; }

__own-create()
{
  local OwnDir="$1" Origin="$2" NewRoot="$3"
  local Source="$OwnDir/$Origin" Target="$NewRoot/$Origin"
  [ -d "$OwnDir" ] || { echo >&2 "*** own: OwnDir='$OwnDir' -- empty argument / not a directory; return"; return 70; }
  [ -e "$Origin" ] || { echo >&2 "*** own: Origin='$Origin' -- empty / non-existing argument; return"; return 70; }
  [ -d "$NewRoot" ] || { echo >&2 "*** own: NewRoot='$NewRoot' -- empty argument / not a directory; return"; return 70; }

  if [ ! -e "$Source" ]; then
    local osrc_type="$(__file-type "$Origin")"
    local deref_osrc_type="${osrc_type##symbolic link / }"
    case "$deref_osrc_type" in
      (directory | regular\ file)
          __replicate-pathname "$Origin" "$OwnDir"  ||
          {
            echo >&2 "*** own-create: '$Source' -- cannot create source from origin '$Origin'; abort"
            return 74
          }
          ;;
      (*)
          echo >&2 "*** own-create: '$Origin' -- unexpected source origin type: $deref_osrc_type; return"
          return 70
          ;;
    esac
  fi
  __own "$OwnDir" "$Origin" "$NewRoot"
  return $?
}
own-create() { __own-create "$OWN_DIR" "$1" "$NEW_ROOT"; }
undo-own-create() { __undo-own "$OWN_DIR" "$1" "$NEW_ROOT"; }


## SUBROUTINES -- CHTOOR COMMANDS

__print-NEW_ROOT-mounts()  # print a summary of the existing bind-mounts for NEW_ROOT hierarchy
{
  echo "---${*:+ $*} '$NEW_ROOT' mounts:"
  findmnt --list --output TARGET,SOURCE,PROPAGATION,OPTIONS  |
  gawk -v NewRoot="$(realpath -q -e "$NEW_ROOT")" -e '
      BEGIN { NewRootStrLen=length(NewRoot) }
      NR == 1  {
        if (index($0, "SOURCE") > 7+NewRootStrLen) $0 = "TARGET" substr($0, 7+NewRootStrLen)
        $0 = gensub(/(\s)OPTIONS$/, "\\1 R/W", 1)
        print
        next
      }
      index($0, NewRoot " ") == 1 || index($0, NewRoot "/") == 1  {
        $0 = substr($0, NewRootStrLen+2)
        $0 = "/" $0
        $0 = gensub(/(\s)(|\S+,)(ro|rw)(,\S+|)$/, "\\1 \\3", 1)
        print | "LC_ALL=C sort"
      }
  '
  echo "---"
}


__chtoor-setup()
{
  ## create a setup establishment marker file
  dd status=none if=/dev/null of="$CHTOOR_DIR/$CHTOOR_MARKER"  ||
  {
    echo >&2 "*** chtoor-setup: '$CHTOOR_DIR/$CHTOOR_MARKER' -- cannot create file; return"
    return 31
  }

  ## create a new root directory
  if [ -e "$NEW_ROOT" ]; then
    ## NEW_ROOT should be a simple directory
    [ -d "$NEW_ROOT" ] || { echo >&2 "*** chtoor-setup: '$NEW_ROOT' -- not a directory; return"; return 32; }
    mountpoint -q "$NEW_ROOT" && { echo >&2 "*** chtoor-setup: '$NEW_ROOT' -- is a mountpoint; return"; return 32; }
    __is-same-file "$NEW_ROOT" "/" && { echo >&2 "*** chtoor-setup: '$NEW_ROOT' -- is the current root; return"; return 32; }
  else
    mkdir -v "$NEW_ROOT" || { echo >&2 "*** chtoor-setup: '$NEW_ROOT' -- cannot create directory; return"; return 32; }
  fi

  local item='' item_methods='' setup_method=''

  ## create a directory for chroot environment's own files
  if [ -e "$OWN_DIR" ]; then
    [ -d "$OWN_DIR" ] || { echo >&2 "*** chtoor-setup: '$OWN_DIR' -- not a directory; return"; return 33; }
    __is-same-file "$OWN_DIR" "/" && { echo >&2 "*** chtoor-setup: '$OWN_DIR' -- is the current root; return"; return 33; }
  else
    for item_methods in "${SETUP[@]}"; do
      setup_method="${item_methods%%!*}"
      if [[ "$setup_method" =~ ^own(-.+|)$ ]]; then
        mkdir -v "$OWN_DIR" || { echo >&2 "*** chtoor-setup: '$OWN_DIR' -- cannot create directory; return"; return 33; }
      fi
      break
    done
  fi

  ## do setup the new root hierarchy
  while IFS='' read -r item; do
    [ -z "$item" ] && continue
    item_methods="${SETUP[$item]}"
    setup_method="${item_methods%%!*}"
    [ -z "$setup_method" ] && continue
    echo "--- chtoor-setup: [$item]='$setup_method'"
    "$setup_method" "$item"  ||
    {
      local -i err_code=$?
      echo >&2 "*** chtoor-setup: '$setup_method' -- method error ($err_code); abort"
      echo >&2 "*** chtoor-setup: there can be several mounts having been done so far"
      __print-NEW_ROOT-mounts "chtoor-setup:"
      return "$err_code";
    }
  done < <(IFS=$'\n'; LC_ALL=C sort <<<"${!SETUP[*]}")
  echo
  __print-NEW_ROOT-mounts "chtoor-setup:"

  ## create a marker file to visually distiguish the new root hierarchy
  if ! __is-same-file "$NEW_ROOT" "/" && [ -w "$NEW_ROOT" ]; then
    sudo dd status=none if=/dev/null of="$NEW_ROOT/$CHTOOR_MARKER"  &&
    sudo chown "$USER:$USER" "$NEW_ROOT/$CHTOOR_MARKER"
  fi

  return 0
}

__chtoor-go()
{
  [ -f "$CHTOOR_DIR/$CHTOOR_MARKER" ]  ||
  __chtoor-setup  &&
  {
    exec sudo --preserve-env chroot --userspec="$USER:$USER" -- "$NEW_ROOT" $RUN
  }
}

__chtoor-undo()
{
  [ -d "$NEW_ROOT" ] || { echo >&2 "*** chtoor-undo: '$NEW_ROOT' -- not a directory; return"; return 51; }
  [ "$(realpath -q -e "$NEW_ROOT")" = "/" ] && { echo >&2 "*** chtoor-undo: '$NEW_ROOT' -- is the current root mountpoint; return"; return 51; }

  ## undo setup for new root hierarchy
  local item='' item_methods='' undo_method=''
  while IFS='' read -r item; do
    [ -z "$item" ] && continue
    item_methods="${SETUP[$item]}"
    undo_method="${item_methods##*!}"
    [ -z "$undo_method" ] && continue
    if [ "$undo_method" = "$item_methods" ]; then
      undo_method="undo-$undo_method"  # default corresponding undo method
      declare -F "$undo_method" >/dev/null || continue  # skip non-existing default corresponding undo method
    fi
    echo "--- chtoor-undo: [$item]='$undo_method'"
    "$undo_method" "$item"  ||
    {
      local -i err_code=$?
      echo >&2 "*** chtoor-undo: '$undo_method' -- method error ($err_code); abort"
      echo >&2 "*** chtoor-undo: some mounts can still remain undone"
      __print-NEW_ROOT-mounts "chtoor-undo:"
      return "$err_code";
    }
  done < <(IFS=$'\n'; LC_ALL=C sort -r <<<"${!SETUP[*]}")  # reverse order

  echo
  if mountpoint -q "$NEW_ROOT"; then
    ## NEW_ROOT should be a simple directory
    echo "umount -R '$NEW_ROOT'"
    sudo umount -v -R "$NEW_ROOT"
  fi
  __print-NEW_ROOT-mounts "chtoor-undo:"

  ## remove marker files
  [ -w "$NEW_ROOT" -a -f "$NEW_ROOT/$CHTOOR_MARKER" ] && rm -v "$NEW_ROOT/$CHTOOR_MARKER"
  rm -v "$CHTOOR_DIR/$CHTOOR_MARKER"

  return 0
}


## MAIN

__verify-setup-items()
{
  local -i ret=0
  local item_src='' item_methods='' setup_method=''
  while IFS='' read -r item_src; do
    [ -z "$item_src" ] && continue  # skip items with empty source
    item_methods="${SETUP[$item_src]}"
    setup_method="${item_methods%%!*}"
    [ -z "$setup_method" ] && continue  # skip items with empty method

    [ -e "$item_src" ]  ||
    {
      echo >&2 "*** SETUP: [$item_src]='$setup_method' -- non-existing origin"
      ret+=1
    }
    declare -F "$setup_method" >/dev/null  ||
    {
      echo >&2 "*** SETUP: [$item_src]='$setup_method' -- unknown setup method"
      ret+=1
    }
    [ "$setup_method" = "own" -a ! -e "$OWN_DIR/$item_src" ]  &&
    {
      echo >&2 "*** SETUP: [$item_src]='$setup_method' -- non-existing source for '$setup_method' method: '$OWN_DIR/$item_src'"
      ret+=1
    }
  done < <(IFS=$'\n'; LC_ALL=C sort <<<"${!SETUP[*]}")
  return "$ret"
}
__verify-undo-items()
{
  local -i ret=0
  local item_methods='' undo_method=''
  for item_methods in "${SETUP[@]}"; do
    undo_method="${item_methods##*!}"
    [ -z "$undo_method" ] && continue  # skip empty records
    [ "$undo_method" = "$item_methods" ] && continue  # no undo method is specified; no matter if the default corresponding undo method exists
    declare -F "$undo_method" >/dev/null && continue
    echo >&2 "*** SETUP: '$undo_method' -- unknown undo method"
    ret+=1
  done
  return "$ret"
}

case "$OPT_MODE" in
  (go | setup | undo)
      ## read the config file
      [ -z "$OPT_CONFIG_FILE" ] && OPT_CONFIG_FILE="$CHTOOR_DIR/chtoor.conf"
      if [ -f "$OPT_CONFIG_FILE" ]; then
        source "$OPT_CONFIG_FILE" || { echo >&2 "*** config file: '$OPT_CONFIG_FILE' -- source failure; exit"; exit 3; }
      fi
      ;;&
  (go | setup)
      if [ ! -f "$OPT_CONFIG_FILE" ]; then
        echo >&2 "*** config file: '$OPT_CONFIG_FILE' -- not found; fall back to minimal setup defaults"
      fi
      ;;&
  (go)
      RUN="${2:-$RUN}"
      if [ ! -f "$CHTOOR_DIR/$CHTOOR_MARKER" ]; then
        __verify-setup-items || { echo >&2 "*** SETUP: verification failed; exit"; exit 4; }
      fi
      ;;
  (setup)
      __verify-setup-items || { echo >&2 "*** SETUP: verification failed; exit"; exit 4; }
      ;;
  (undo)
      if [ ! -f "$OPT_CONFIG_FILE" ]; then
        echo >&2 "*** config file: '$OPT_CONFIG_FILE' -- not found; minimal default setup assumed"
      fi
      __verify-undo-items || { echo >&2 "*** SETUP: verification failed; exit"; exit 4; }
      ;;
esac
__chtoor-"$OPT_MODE"

exit


is-root()  { [ "$(realpath -q -e "$1")" = "/" ]; }
is-same()
{
  local LHS="$(realpath -q -e "$1")" RHS="$(realpath -q -e "$2")"
  [ -n "$LHS" -a -n "$RHS" -a "$LHS" = "$RHS" ]
}


__do-bind()
{
  local SOURCE="$1" CHROOT="$2" TARGET="$2/$1"
  [ -n "$SOURCE" ] || return 1
  [ -d "$CHROOT" ] || return 2
  ! is-root "$CHROOT" || return 3
  ! mountpoint -q "$TARGET" || return 4
  ! is-same "$SOURCE" "$TARGET" || return 6

  local -i opt_ro=$(($3&1)) opt_recursive=$(($3&2))

  local source_type="$(stat --printf=%F "$SOURCE")"
  case "$source_type" in
    (directory)
        if [ ! -d "$TARGET" ]; then
          [ ! -e "$TARGET" ]  &&
          {
            sudo mkdir -v -p "$TARGET"  &&
            sudo chown -v "$USER:$USER" "$TARGET"
          }  ||
          return 41
        fi
        if sudo mount -v --bind "$SOURCE" "$TARGET"; then
          [ "$opt_ro" -ne 0 ] && sudo mount -v -o remount,ro,bind "$SOURCE" "$TARGET"
          if [ "$opt_recursive" -ne 0 ]; then
            findmnt --raw --noheadings --output TARGET --submounts --uniq '/'  |
            LC_ALL=C sort  |
            while IFS='' read -r src; do
              [ "$src" = "$SOURCE" ] && continue
              [ "${src:0:${#SOURCE}}" = "$SOURCE" ] && __do-bind "$src" "$CHROOT" $opt_ro
            done
          fi
        else
          return 51
        fi
        ;;
    (regular\ file)
        if [ ! -f "$TARGET" ]; then
          [ ! -e "$TARGET" ]  &&
          {
            sudo dd status=none if=/dev/null of="$TARGET"  &&
            sudo chown -v "$USER:$USER" "$TARGET"
          }  ||
          return 42
        fi
        if sudo mount -v --bind "$SOURCE" "$TARGET"; then
          [ "$opt_ro" -ne 0 ] && sudo mount -v -o remount,ro,bind "$SOURCE" "$TARGET"
        else
          return 52
        fi
        ;;
    (symbolic\ link)
        sudo cp -v -P --preserve=all -T "$SOURCE" "$TARGET" || return 43
        ;;
    (*)
        return 5
        ;;
  esac
  return 0
}
bind()  { __do-bind "$1" "$2" 0; }
bind-ro()  { __do-bind "$1" "$2" 1; }
rbind()  { __do-bind "$1" "$2" 2; }
rbind-ro()  { __do-bind "$1" "$2" 3; }

__undo-bind()
{
  local SOURCE="$1" CHROOT="$2" TARGET="$2/$1"
  [ -n "$SOURCE" ] || return 1
  [ -d "$CHROOT" ] || return 2
  ! is-root "$CHROOT" || return 3
  ! is-same "$SOURCE" "$TARGET" || return 6

  shift 2

  local source_type="$(stat --printf=%F "$SOURCE")"
  case "$source_type" in
    (directory | regular\ file)
        if mountpoint "$TARGET"; then
          sudo umount -v "$@" "$TARGET"  ||
          {
            sudo fuser -v -m "$TARGET"
            return 4
          }
        fi
        ;;
    (symbolic\ link)
        if [ -L "$TARGET" ]; then
          sudo rm -v "$TARGET"  || return 43
        else
          echo >&2 "__undo-bind: '$TARGET' is not a symbolic link"
        fi
        ;;
    (*)
        return 5
        ;;
  esac
}
undo-bind()  { __undo-bind "$1" "$2"; }
undo-bind-ro()  { __undo-bind "$1" "$2"; }
undo-rbind()  { __undo-bind "$1" "$2" -R; }
undo-rbind-ro()  { __undo-bind "$1" "$2" -R; }


__clone_target_path()
{
  local SOURCE="$1" CHROOT="$2" TARGET="$2/$1"
  [ -n "$SOURCE" ] || return 1
  [ -d "$CHROOT" ] || return 2
  ! is-root "$CHROOT" || return 3
  ! mountpoint -q "$TARGET" || return 4
  ! is-same "$SOURCE" "$TARGET" || return 5

  local src="" tgt="$CHROOT" pth=""
  while IFC='' read -r -d '/' pth || [ "$pth" ]; do
    [ -z "$pth" ] && continue;
    [ "$pth" = "." ] && { src="${src:-.}"; continue; }
    src="$src/$pth"
    tgt="$tgt/$pth"
    [ "$pth" = ".." ] && continue

    if [ -e "$src" -a ! -d "$src" ]; then
      echo >&2 "$0: '$tgt' -- $(stat --printf=%F "$src") in the path to '$TARGET'"
      return 11
    fi
    if mountpoint -q "$tgt"; then
      echo >&2 "$0: '$tgt' -- mount point in the path to '$TARGET'"
      return 14
    fi

    sudo mkdir -v -p "$tgt" || return 10
    sudo chmod -v --reference="$src" "$tgt"
    sudo chown -v --reference="$src" "$tgt"
    sudo chcon -v --reference="$src" "$tgt"
  done < <(dirname "$SOURCE")
}

__create()
{
  local SOURCE="$1" CHROOT="$2" TARGET="$2/$1"
  [ -n "$SOURCE" ] || return 1
  [ -d "$CHROOT" ] || return 2
  ! is-root "$CHROOT" || return 3
  ! mountpoint -q "$TARGET" || return 4
  ! is-same "$SOURCE" "$TARGET" || return 5

  local source_type="$(stat --printf=%F "$SOURCE")"
  case "$source_type" in
    (directory)
        __clone_target_path "$SOURCE" "$CHROOT" || return
        sudo mkdir -v -p "$TARGET" || return 41
        sudo chmod -v --reference="$SOURCE" "$TARGET"
        sudo chown -v --reference="$SOURCE" "$TARGET"
        sudo chcon -v --reference="$SOURCE" "$TARGET"
        ;;
    (regular\ file)
        __clone_target_path "$SOURCE" "$CHROOT" || return
        sudo dd status=none if=/dev/null of="$TARGET" || return 42;
        sudo chmod -v --reference="$SOURCE" "$TARGET"
        sudo chown -v --reference="$SOURCE" "$TARGET"
        sudo chcon -v --reference="$SOURCE" "$TARGET"
        ;;
    (symbolic\ link)
        __clone_target_path "$SOURCE" "$CHROOT" || return
        sudo cp -v -P --preserve=all -T "$SOURCE" "$TARGET" || return 43
        ;;
    (*)
        return 6
        ;;
  esac
}
create()  { __create "$1" "$2"; }
create-if-not-exist()  { [ -e "$2/$1" ] || __create "$1" "$2"; }


__copy()
{
  local SOURCE="$1" CHROOT="$2" TARGET="$2/$1"
  [ -n "$SOURCE" ] || return 1
  [ -d "$CHROOT" ] || return 2
  ! is-root "$CHROOT" || return 3
  ! mountpoint -q "$TARGET" || return 4
  ! is-same "$SOURCE" "$TARGET" || return 5

  shift 2

  local source_type="$(stat --printf=%F "$SOURCE")"
  case "$source_type" in
    (directory)
        __clone_target_path "$SOURCE" "$CHROOT" || return
        sudo cp -v --preserve=all -R "$@" -T "$SOURCE" "$TARGET" || return 41
        ;;
    (regular\ file)
        __clone_target_path "$SOURCE" "$CHROOT" || return
        sudo cp -v --preserve=all "$@" -T "$SOURCE" "$TARGET" || return 42
        ;;
    (symbolic\ link)
        __clone_target_path "$SOURCE" "$CHROOT" || return
        sudo cp -v -P --preserve=all "$@" -T "$SOURCE" "$TARGET" || return 43
        ;;
    (*)
        return 5
        ;;
  esac
}
copy()  { __copy "$1" "$2"; }
copy-if-not-exist()  { [ -e "$2/$1" ] || __copy "$1" "$2"; }
copy-update()  { __copy "$1" "$2" -u; }


chroot-setup()
{
  local CHROOT="$1"
  [ -d "$CHROOT" ] || return 1
  ! is-root "$CHROOT" || return 2
  ! mountpoint -q "$CHROOT" || return 3

  local source="" method=""
  for method in "${CHROOT_SETUP[@]}"; do
    method="${method%%!*}"
    [ -z "$method" ] && continue
    if ! declare -F "$method" >/dev/null; then
      echo >&2 "$0: unknown setup method -- '$method'"
      return 4
    fi
  done

  sudo dd status=none if=/dev/null of="$CHROOT/.chroot"  &&
  sudo chown "$USER:$USER" "$CHROOT/.chroot"  ||
  return 5

  while IFS='' read -r source; do
    [ -z "$source" ] && continue
    method="${CHROOT_SETUP[$source]%%!*}"
    [ -z "$method" ] && continue
    echo "[$source]: $method"
    "$method" "$source" "$CHROOT"  ||
    {
      local -i err_code=$?
      echo >&2 "$0: $method error $err_code"
      return "$err_code";
    }
    echo
  done < <(IFS=$'\n'; LC_ALL=C sort <<<"${!CHROOT_SETUP[*]}")

  findmnt --list  |
  sed -b -n -e '1{p; b;}; \'$'\x01'"${CHROOT}"$'\x01''p'  |
  awk -e 'NR>1 {print | "LC_ALL=C sort"; next}; NR==1'
}
chroot-undo()
{
  local CHROOT="$1"
  [ -d "$CHROOT" ] || return 1
  ! is-root "$CHROOT" || return 2
  ! mountpoint -q "$CHROOT" || return 3

  local source="" method=""
  for method in "${CHROOT_SETUP[@]}"; do
    method="${method##*!}"
    [ -z "$method" ] && continue
    method="undo-$method"
    if ! declare -F "$method" >/dev/null; then
      echo >&2 "$0: unknown undo method -- '$method'"
      return 4
    fi
  done

  while IFS='' read -r source; do
    [ -z "$source" ] && continue
    method="${CHROOT_SETUP[$source]##*!}"
    [ -z "$method" ] && continue
    method="undo-$method"
    echo "[$source]: $method"
    "$method" "$source" "$CHROOT"  ||
    {
      local -i err_code=$?
      echo >&2 "$0: $method error $err_code"
      return "$err_code";
    }
    echo
  done < <(IFS=$'\n'; LC_ALL=C sort <<<"${!CHROOT_SETUP[*]}")

  findmnt --list  |
  sed -b -n -e '1{p; b;}; \'$'\x01'"${CHROOT}"$'\x01''p'  |
  awk -e 'NR>1 {print | "LC_ALL=C sort"; next}; NR==1'

  rm -v "$CHROOT/.chroot"
}


chroot-go()
{
  local CHROOT="$1"
  [ -d "$CHROOT" ] || return 1
  ! is-root "$CHROOT" || return 2

  shift

  [ -f "$CHROOT/.chroot" ]  ||
  chroot-setup "$CHROOT"  &&
  {
    sudo chroot -- "$CHROOT" su "$USER" "$@"
  }
}



chroot-"$OPT_COMMAND" "$@"

